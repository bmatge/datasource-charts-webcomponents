/**
 * Code generation functions.
 * Contains all code generation paths: local data, dynamic Grist,
 * dynamic API, and standard API-fetched data.
 */

import {
  escapeHtml,
  formatKPIValue,
  toNumber,
  isValidDeptCode,
  toastWarning,
  toastError,
  CDN_URLS,
  DSFR_TAG_MAP,
  filterToOdsql,
  applyLocalFilter,
  detectProvider,
  extractResourceIds,
  getProvider,
} from '@gouv-widgets/shared';
import { state, PROXY_BASE_URL } from '../state.js';
import { renderChart } from './chart-renderer.js';
import { updateAccessibleTable } from './accessible-table.js';

const ODS_PAGE_SIZE = 100;
const ODS_MAX_PAGES = 10;

/**
 * Fetch all results from an ODS API URL, handling pagination automatically.
 * ODS APIs cap at 100 records per request. When the URL requests more,
 * this function uses offset-based pagination to accumulate all results.
 */
async function fetchOdsResults(baseUrl: string): Promise<Record<string, unknown>[]> {
  const url = new URL(baseUrl);
  const requestedLimit = parseInt(url.searchParams.get('limit') || '0', 10);

  // limit <= 0 means "fetch all" with auto-pagination
  // limit <= 100 means single page (no pagination needed)
  if (requestedLimit > 0 && requestedLimit <= ODS_PAGE_SIZE) {
    const response = await fetch(baseUrl);
    const json = await response.json();
    return json.results || [];
  }

  const effectiveLimit = requestedLimit > 0 ? requestedLimit : ODS_MAX_PAGES * ODS_PAGE_SIZE;
  let allResults: Record<string, unknown>[] = [];
  let offset = 0;
  let totalCount = -1;

  for (let page = 0; page < ODS_MAX_PAGES; page++) {
    const remaining = effectiveLimit - allResults.length;
    if (remaining <= 0) break;

    const pageUrl = new URL(baseUrl);
    pageUrl.searchParams.set('limit', String(Math.min(ODS_PAGE_SIZE, remaining)));
    pageUrl.searchParams.set('offset', String(offset));

    const response = await fetch(pageUrl.toString());
    const json = await response.json();
    const pageResults = (json.results || []) as Record<string, unknown>[];
    allResults = allResults.concat(pageResults);

    if (typeof json.total_count === 'number') totalCount = json.total_count;

    if (pageResults.length < ODS_PAGE_SIZE) break;
    if (totalCount >= 0 && allResults.length >= totalCount) break;
    offset += pageResults.length;
  }

  // Verify total_count coherence
  if (totalCount >= 0 && allResults.length < totalCount && allResults.length < effectiveLimit) {
    console.warn(
      `fetchOdsResults: pagination incomplete - ${allResults.length}/${totalCount} resultats`
    );
  }

  return allResults;
}

// DSFR_TAG_MAP imported from @gouv-widgets/shared

/** Build DSFR Chart specific attributes from builder state */
function dsfrChartAttrs(): string {
  const extra: string[] = [];
  if (state.chartType === 'horizontalBar') extra.push('horizontal');
  if (state.chartType === 'pie') extra.push('fill');
  if (state.chartType === 'doughnut') { /* no fill = donut */ }
  return extra.map(a => `\n    ${a}`).join('');
}

/**
 * Escape single quotes in a string for use inside single-quoted HTML attributes.
 * DSFR Chart x/y attributes contain JSON with French names that may include
 * apostrophes (e.g. "CÔTES-D'ARMOR", "VAL-D'OISE") which would prematurely
 * close the HTML attribute if unescaped.
 */
function escapeSingleQuotes(value: string): string {
  return value.replace(/'/g, '&#39;');
}

/**
 * Inline JS helper for ODS pagination in generated code.
 * Handles offset-based pagination (ODS API max 100 records/request).
 */
const ODS_FETCH_HELPER = `// Pagination ODS (max 100 par requete)
async function fetchAllODS(apiUrl) {
  var allResults = [], offset = 0, url = new URL(apiUrl);
  var limit = parseInt(url.searchParams.get('limit') || '100');
  for (var p = 0; p < 10; p++) {
    var rem = limit - allResults.length;
    if (rem <= 0) break;
    var u = new URL(apiUrl);
    u.searchParams.set('limit', String(Math.min(100, rem)));
    u.searchParams.set('offset', String(offset));
    var r = await fetch(u.toString());
    var j = await r.json();
    var d = j.results || [];
    allResults = allResults.concat(d);
    if (d.length < 100 || (j.total_count && allResults.length >= j.total_count)) break;
    offset += d.length;
  }
  return allResults;
}`;

/**
 * Generate an inline <script> that re-applies DSFR Chart element attributes
 * after Vue mount. DSFR Chart Vue components overwrite certain attributes
 * (value, date) with defaults during mount.
 */
function dsfrDeferredScript(tagName: string): string {
  return `
<script>
(function(){var c=document.querySelector('${tagName}');if(!c)return;var s={};[].forEach.call(c.attributes,function(a){s[a.name]=a.value});customElements.whenDefined('${tagName}').then(function(){setTimeout(function(){Object.keys(s).forEach(function(k){c.setAttribute(k,s[k])})},500)})})();
<\/script>`;
}

// filterToOdsql and applyLocalFilter imported from @gouv-widgets/shared

/**
 * Generate optional middleware elements (gouv-normalize, gouv-facets)
 * to insert between gouv-source and gouv-query/gouv-dsfr-chart.
 * Returns the generated HTML and the final source ID for downstream components.
 */
/**
 * Options pour le mode de fonctionnement des facettes.
 * - serverFacets: mode serveur ODS (fetch depuis /facets API)
 * - staticValues: valeurs pre-calculees avec WHERE en colon syntax (Tabular/Grist)
 */
export interface FacetsMode {
  serverFacets?: boolean;
  staticValues?: Record<string, string[]>;
  /** Prefix to prepend to field names (e.g. "fields." for Grist without flatten) */
  fieldPrefix?: string;
}

/**
 * Generate a <gouv-facets> element if facets are enabled and configured.
 * Returns the generated HTML and the new source ID for downstream components,
 * or empty string/unchanged sourceId if facets are not enabled.
 */
export function generateFacetsElement(
  sourceId: string,
  mode?: FacetsMode
): { element: string; finalSourceId: string } {
  const activeFields = state.facetsConfig.fields.filter(f => f.field);
  if (!state.facetsConfig.enabled || activeFields.length === 0) {
    return { element: '', finalSourceId: sourceId };
  }

  const facetsId = 'faceted-data';
  const attrs: string[] = [`source="${sourceId}"`];
  const pfx = mode?.fieldPrefix || '';

  attrs.push(`fields="${activeFields.map(f => pfx + f.field).join(', ')}"`);

  const labelsWithCustom = activeFields.filter(f => f.label && f.label !== f.field);
  if (labelsWithCustom.length > 0) {
    attrs.push(`labels="${escapeHtml(labelsWithCustom.map(f => `${pfx}${f.field}:${f.label}`).join(' | '))}"`);
  }

  const nonDefaultDisplay = activeFields.filter(f => f.display !== 'checkbox');
  if (nonDefaultDisplay.length > 0) {
    attrs.push(`display="${nonDefaultDisplay.map(f => `${pfx}${f.field}:${f.display}`).join(' | ')}"`);
  }

  const disjunctiveFields = activeFields.filter(f => f.disjunctive);
  if (disjunctiveFields.length > 0) {
    attrs.push(`disjunctive="${disjunctiveFields.map(f => pfx + f.field).join(', ')}"`);
  }

  const searchableFields = activeFields.filter(f => f.searchable);
  if (searchableFields.length > 0) {
    attrs.push(`searchable="${searchableFields.map(f => pfx + f.field).join(', ')}"`);
  }

  if (state.facetsConfig.maxValues !== 6) {
    attrs.push(`max-values="${state.facetsConfig.maxValues}"`);
  }
  if (state.facetsConfig.sort !== 'count') {
    attrs.push(`sort="${state.facetsConfig.sort}"`);
  }
  if (state.facetsConfig.hideEmpty) {
    attrs.push('hide-empty');
  }

  // Mode server-facets (ODS)
  if (mode?.serverFacets) {
    attrs.push('server-facets');
  }

  // Mode static-values (Tabular/Grist) : valeurs pre-calculees
  if (mode?.staticValues) {
    const json = JSON.stringify(mode.staticValues);
    attrs.push(`static-values='${json}'`);
  }

  const element = `
  <!-- Filtres a facettes -->
  <gouv-facets
    id="${facetsId}"
    ${attrs.join('\n    ')}>
  </gouv-facets>`;

  return { element, finalSourceId: facetsId };
}

/**
 * Pre-compute unique values for facet fields from loaded data.
 * Used to generate static-values for non-ODS sources.
 */
export function computeStaticFacetValues(): Record<string, string[]> | null {
  const activeFields = state.facetsConfig.fields.filter(f => f.field);
  if (!state.facetsConfig.enabled || activeFields.length === 0) return null;
  if (!state.localData || state.localData.length === 0) return null;

  const result: Record<string, string[]> = {};
  for (const fieldConfig of activeFields) {
    const field = fieldConfig.field;
    const uniqueValues = new Set<string>();
    for (const row of state.localData) {
      const val = row[field];
      if (val !== null && val !== undefined && val !== '') {
        uniqueValues.add(String(val));
      }
    }
    if (uniqueValues.size > 0 && uniqueValues.size <= 200) {
      result[field] = [...uniqueValues].sort();
    }
  }
  return Object.keys(result).length > 0 ? result : null;
}

export function generateMiddlewareElements(
  sourceId: string,
  facetsMode?: FacetsMode
): { elements: string; finalSourceId: string } {
  let currentSourceId = sourceId;
  let elements = '';

  // gouv-normalize
  if (state.normalizeConfig.enabled) {
    const normalizeId = 'normalized-data';
    const attrs: string[] = [`source="${currentSourceId}"`];
    if (state.normalizeConfig.trim) attrs.push('trim');
    if (state.normalizeConfig.numericAuto) attrs.push('numeric-auto');
    if (state.normalizeConfig.numeric) attrs.push(`numeric="${escapeHtml(state.normalizeConfig.numeric)}"`);
    if (state.normalizeConfig.rename) attrs.push(`rename="${escapeHtml(state.normalizeConfig.rename)}"`);
    if (state.normalizeConfig.stripHtml) attrs.push('strip-html');
    if (state.normalizeConfig.replace) attrs.push(`replace="${escapeHtml(state.normalizeConfig.replace)}"`);
    if (state.normalizeConfig.lowercaseKeys) attrs.push('lowercase-keys');
    if (state.normalizeConfig.flatten) attrs.push(`flatten="${escapeHtml(state.normalizeConfig.flatten)}"`);

    elements += `
  <!-- Nettoyage des donnees -->
  <gouv-normalize
    id="${normalizeId}"
    ${attrs.join('\n    ')}>
  </gouv-normalize>`;
    currentSourceId = normalizeId;
  }

  // gouv-facets
  const facets = generateFacetsElement(currentSourceId, facetsMode);
  if (facets.element) {
    elements += facets.element;
    currentSourceId = facets.finalSourceId;
  }

  return { elements, finalSourceId: currentSourceId };
}

/**
 * Build the colonnes attribute for gouv-datalist.
 * Uses custom column config if available, otherwise auto-detects from fields.
 */
function buildColonnesAttr(): string {
  // Use custom columns if configured
  const visibleCols = state.datalistColumns.filter(c => c.visible);
  if (visibleCols.length > 0) {
    return visibleCols.map(c => `${c.field}:${c.label}`).join(', ');
  }
  // Fallback: auto-detect from fields or raw data
  const fields = state.fields.length > 0
    ? state.fields.map(f => f.name)
    : (state.localData && state.localData.length > 0 ? Object.keys(state.localData[0]) : []);
  return fields.map(f => `${f}:${f}`).join(', ');
}

/**
 * Build optional datalist attributes (recherche, filtres, export) from state.
 */
function buildDatalistAttrs(): string {
  let attrs = '';
  if (state.datalistRecherche) attrs += '\n    recherche';
  const exportFormats: string[] = [];
  if (state.datalistExportCsv) exportFormats.push('csv');
  if (state.datalistExportHtml) exportFormats.push('html');
  if (exportFormats.length > 0) attrs += `\n    export="${exportFormats.join(',')}"`;

  const filtrables = state.datalistColumns.filter(c => c.visible && c.filtrable).map(c => c.field);
  if (state.datalistFiltres && filtrables.length > 0) {
    attrs += `\n    filtres="${filtrables.join(',')}"`;
  }
  return attrs;
}

/**
 * Main orchestrator: reads form state, validates, routes to correct code gen path.
 */
export async function generateChart(): Promise<void> {
  // Get current values from form
  const labelField = document.getElementById('label-field') as HTMLSelectElement | null;
  const valueField = document.getElementById('value-field') as HTMLSelectElement | null;
  const valueField2 = document.getElementById('value-field-2') as HTMLSelectElement | null;
  const codeField = document.getElementById('code-field') as HTMLSelectElement | null;
  const aggregation = document.getElementById('aggregation') as HTMLSelectElement | null;
  const sortOrder = document.getElementById('sort-order') as HTMLSelectElement | null;

  if (labelField) state.labelField = labelField.value;
  if (valueField) state.valueField = valueField.value;
  state.valueField2 = valueField2?.value || '';
  state.codeField = codeField?.value || '';
  if (aggregation) state.aggregation = aggregation.value as typeof state.aggregation;
  if (sortOrder) state.sortOrder = sortOrder.value as typeof state.sortOrder;

  const isKPI = state.chartType === 'kpi';
  const isGauge = state.chartType === 'gauge';
  const isDatalist = state.chartType === 'datalist';
  const isMap = state.chartType === 'map';
  const isSingleValue = isKPI || isGauge;

  // Validation: datalist only needs labelField, KPI/Gauge need valueField, charts need both
  if (isDatalist && !state.labelField) {
    toastWarning('Veuillez s\u00e9lectionner un champ pour les colonnes');
    return;
  }
  if (!isSingleValue && !isDatalist && (!state.labelField || !state.valueField)) {
    toastWarning('Veuillez s\u00e9lectionner les champs pour les axes X et Y');
    return;
  }
  if (isSingleValue && !state.valueField && state.aggregation !== 'count') {
    toastWarning('Veuillez s\u00e9lectionner un champ pour la valeur');
    return;
  }

  // Datalist: route to local data path (no aggregation needed)
  if (isDatalist) {
    if (state.sourceType === 'saved' && state.localData && state.localData.length > 0) {
      generateChartFromLocalData();
    } else {
      // For API sources, use raw data — limit=200 to fetch all records
      const params = new URLSearchParams({ limit: '200' });
      if (state.advancedMode && state.queryFilter) {
        const odsql = filterToOdsql(state.queryFilter);
        if (odsql) params.set('where', odsql);
      }
      const apiUrl = `${state.apiUrl}?${params}`;
      try {
        state.data = await fetchOdsResults(apiUrl);
        state.localData = state.data as Record<string, unknown>[];
        renderChart();
        generateCode(apiUrl);
      } catch (error) {
        toastError('Erreur lors du chargement des donn\u00e9es : ' + (error as Error).message);
      }
    }
    return;
  }

  // Check if using local data
  if (state.sourceType === 'saved' && state.localData && state.localData.length > 0) {
    generateChartFromLocalData();
    return;
  }

  // Build API URL with aggregation
  const valueExpression = state.aggregation === 'count'
    ? 'count(*) as value'
    : `${state.aggregation}(${state.valueField}) as value`;

  // Handle second series if defined
  const hasSecondSeries = state.valueField2 && ['bar', 'horizontalBar', 'line', 'radar'].includes(state.chartType);
  const valueExpression2 = hasSecondSeries
    ? `, ${state.aggregation}(${state.valueField2}) as value2`
    : '';

  let params: URLSearchParams;
  if (isSingleValue) {
    // KPI/Gauge: just get the single aggregated value, no group_by
    params = new URLSearchParams({
      select: valueExpression,
      limit: '1',
    });
  } else if (isMap) {
    // Map: group by code field — limit=200 to fetch all departments (API default is 10)
    params = new URLSearchParams({
      select: `${state.codeField}, ${valueExpression}`,
      group_by: state.codeField,
      limit: '200',
    });
  } else {
    // Chart: group by label field — limit=200 to fetch all categories
    params = new URLSearchParams({
      select: `${state.labelField}, ${valueExpression}${valueExpression2}`,
      group_by: state.labelField,
      order_by: `value ${state.sortOrder}`,
      limit: '200',
    });
  }

  // Apply advanced mode filter to API request
  if (state.advancedMode && state.queryFilter) {
    const odsql = filterToOdsql(state.queryFilter);
    if (odsql) params.set('where', odsql);
  }

  const apiUrl = `${state.apiUrl}?${params}`;

  try {
    state.data = await fetchOdsResults(apiUrl);

    // Update raw data view
    const rawDataEl = document.getElementById('raw-data');
    if (rawDataEl) rawDataEl.textContent = JSON.stringify(state.data, null, 2);

    // Render chart or KPI
    renderChart();

    // Generate code
    generateCode(apiUrl);

    // Update accessible table (only for charts)
    if (!isKPI) {
      updateAccessibleTable();
    }
  } catch (error) {
    console.error(error);
    toastError('Erreur lors du chargement des donn\u00e9es : ' + (error as Error).message);
  }
}

/**
 * Aggregate local data client-side, render, and generate code.
 */
export function generateChartFromLocalData(): void {
  // Datalist: skip aggregation, use raw data
  if (state.chartType === 'datalist') {
    let filteredLocal = state.localData || [];
    if (state.advancedMode && state.queryFilter) {
      filteredLocal = applyLocalFilter(filteredLocal as Record<string, unknown>[], state.queryFilter);
    }
    state.data = filteredLocal as any[];

    const rawDataEl = document.getElementById('raw-data');
    if (rawDataEl) rawDataEl.textContent = JSON.stringify(state.data, null, 2);

    renderChart();

    if (state.generationMode === 'dynamic') {
      if (state.savedSource?.type === 'grist') {
        generateDynamicCode();
      } else if (state.savedSource?.type === 'api') {
        generateDynamicCodeForApi();
      } else {
        generateCodeForLocalData();
      }
    } else {
      generateCodeForLocalData();
    }
    return;
  }

  // Aggregate local data
  const aggregated: Record<string, { values: number[]; values2: number[]; count: number }> = {};

  // For maps, aggregate by codeField; for other charts, by labelField
  const isMap = state.chartType === 'map';
  const groupField = isMap ? state.codeField : state.labelField;
  const hasSecondSeries = state.valueField2 && ['bar', 'horizontalBar', 'line', 'radar'].includes(state.chartType);

  // Apply advanced mode filter to local data
  let filteredLocal = state.localData || [];
  if (state.advancedMode && state.queryFilter) {
    filteredLocal = applyLocalFilter(filteredLocal as Record<string, unknown>[], state.queryFilter);
  }

  if (filteredLocal) {
    filteredLocal.forEach(record => {
      const rawGroupKey = record[groupField] as string | number | null;
      // For maps, skip records with invalid codes
      if (isMap && (rawGroupKey === null || rawGroupKey === undefined || rawGroupKey === '')) {
        return; // Skip this record
      }
      const groupKey = String(rawGroupKey || 'N/A');
      const value = toNumber(record[state.valueField]);

      if (!aggregated[groupKey]) {
        aggregated[groupKey] = { values: [], values2: [], count: 0 };
      }
      aggregated[groupKey].values.push(value);
      if (hasSecondSeries) {
        aggregated[groupKey].values2.push(toNumber(record[state.valueField2]));
      }
      aggregated[groupKey].count++;
    });
  }

  // Apply aggregation function
  function applyAgg(vals: number[], count: number): number {
    switch (state.aggregation) {
      case 'sum': return vals.reduce((a, b) => a + b, 0);
      case 'count': return count;
      case 'min': return Math.min(...vals);
      case 'max': return Math.max(...vals);
      case 'avg':
      default: return vals.reduce((a, b) => a + b, 0) / vals.length;
    }
  }

  let results = Object.entries(aggregated).map(([groupKey, data]) => {
    const value = applyAgg(data.values, data.count);
    const result: Record<string, unknown> = { value };

    // For maps, include codeField; for others, include labelField
    if (isMap) {
      result[state.codeField] = groupKey;
    } else {
      result[state.labelField] = groupKey;
    }

    // Second series
    if (hasSecondSeries && data.values2.length > 0) {
      result.value2 = applyAgg(data.values2, data.count);
    }

    return result;
  });

  // Sort
  results.sort((a, b) => {
    return state.sortOrder === 'desc'
      ? (b.value as number) - (a.value as number)
      : (a.value as number) - (b.value as number);
  });

  state.data = results;

  // Update raw data view
  const rawDataEl = document.getElementById('raw-data');
  if (rawDataEl) rawDataEl.textContent = JSON.stringify(state.data, null, 2);

  // Render chart
  renderChart();

  // Generate code based on mode
  if (state.generationMode === 'dynamic') {
    if (state.savedSource?.type === 'grist') {
      generateDynamicCode();
    } else if (state.savedSource?.type === 'api') {
      generateDynamicCodeForApi();
    } else {
      generateCodeForLocalData();
    }
  } else {
    generateCodeForLocalData();
  }

  // Update accessible table
  updateAccessibleTable();
}

/**
 * Generate embedded HTML+JS code for local data.
 */
export function generateCodeForLocalData(): void {
  const codeEl = document.getElementById('generated-code');
  if (!codeEl) return;

  // Handle KPI type
  if (state.chartType === 'kpi') {
    const value = state.data[0]?.value || 0;
    const variantSelect = document.getElementById('kpi-variant') as HTMLSelectElement | null;
    const unitInput = document.getElementById('kpi-unit') as HTMLInputElement | null;
    const variant = variantSelect?.value || '';
    const unit = unitInput?.value || '';

    const code = `<!-- KPI g\u00e9n\u00e9r\u00e9 avec gouv-widgets Builder -->
<!-- Source : ${state.savedSource?.name || 'Donn\u00e9es locales'} -->

<!-- D\u00e9pendances CSS (DSFR) -->
<link rel="stylesheet" href="${CDN_URLS.dsfrCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrUtilityCss}">

<style>
.kpi-card {
  background: var(--background-default-grey);
  border-left: 4px solid var(--border-default-grey);
  padding: 1.5rem 2rem;
  text-align: center;
  border-radius: 4px;
}
.kpi-card--info { border-left-color: #0063CB; }
.kpi-card--success { border-left-color: #18753C; }
.kpi-card--warning { border-left-color: #D64D00; }
.kpi-card--error { border-left-color: #C9191E; }
.kpi-value { display: block; font-size: 2.5rem; font-weight: 700; color: var(--text-title-grey); }
.kpi-label { display: block; font-size: 0.875rem; color: var(--text-mention-grey); margin-top: 0.5rem; }
</style>

<div class="fr-container fr-my-4w">
  <div class="kpi-card${variant ? ' kpi-card--' + variant : ''}">
    <span class="kpi-value">${formatKPIValue(value, unit)}</span>
    <span class="kpi-label">${escapeHtml(state.title)}</span>
  </div>
</div>`;
    codeEl.textContent = code;
    return;
  }

  // Handle Gauge type (local data)
  if (state.chartType === 'gauge') {
    const value = Math.round(state.data[0]?.value || 0);
    const code = `<!-- Jauge g\u00e9n\u00e9r\u00e9e avec gouv-widgets Builder -->
<!-- Source : ${state.savedSource?.name || 'Donn\u00e9es locales'} -->

<!-- D\u00e9pendances (DSFR Chart) -->
<link rel="stylesheet" href="${CDN_URLS.dsfrCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrChartCss}">
<script type="module" src="${CDN_URLS.dsfrChartJs}"><\/script>

<div class="fr-container fr-my-4w">
  <h2>${escapeHtml(state.title)}</h2>
  ${state.subtitle ? `<p class="fr-text--sm fr-text--light">${escapeHtml(state.subtitle)}</p>` : ''}
  <gauge-chart percent="${value}" init="0" target="100"></gauge-chart>
</div>`;
    codeEl.textContent = code;
    return;
  }

  // Handle Datalist type (local data)
  if (state.chartType === 'datalist') {
    const colonnes = buildColonnesAttr();
    const triAttr = state.sortOrder !== 'none' && state.labelField
      ? `\n    tri="${state.labelField}:${state.sortOrder}"` : '';
    const code = `<!-- Tableau genere avec gouv-widgets Builder -->
<!-- Source : ${state.savedSource?.name || 'Donnees locales'} -->

<!-- Dependances CSS (DSFR) -->
<link rel="stylesheet" href="${CDN_URLS.dsfrCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrUtilityCss}">

<!-- Dependances JS -->
<script src="${PROXY_BASE_URL}/dist/gouv-widgets.umd.js"><\/script>

<div class="fr-container fr-my-4w">
  ${state.title ? `<h2>${escapeHtml(state.title)}</h2>` : ''}
  ${state.subtitle ? `<p class="fr-text--sm fr-text--light">${escapeHtml(state.subtitle)}</p>` : ''}

  <gouv-datalist
    id="my-table"
    colonnes="${colonnes}"${buildDatalistAttrs()}${triAttr}
    pagination="10">
  </gouv-datalist>
</div>

<script>
// Donnees integrees
const data = ${JSON.stringify(state.localData?.slice(0, 500) || [], null, 2)};

// Injecter les donnees dans le composant
const datalist = document.getElementById('my-table');
datalist.onSourceData(data);
<\/script>`;
    codeEl.textContent = code;
    return;
  }

  // Handle Scatter type (local data)
  if (state.chartType === 'scatter') {
    const xValues = state.data.map(d => (d[state.labelField] as number) || 0);
    const yValues = state.data.map(d => (d.value as number) || 0);
    const code = `<!-- Nuage de points genere avec gouv-widgets Builder -->
<!-- Source : ${state.savedSource?.name || 'Donnees locales'} -->

<link rel="stylesheet" href="${CDN_URLS.dsfrCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrChartCss}">
<script type="module" src="${CDN_URLS.dsfrChartJs}"><\/script>

<div class="fr-container fr-my-4w">
  <h2>${escapeHtml(state.title)}</h2>

  <scatter-chart
    x='${escapeSingleQuotes(JSON.stringify([xValues]))}'
    y='${escapeSingleQuotes(JSON.stringify([yValues]))}'
    name='${escapeSingleQuotes(JSON.stringify([`${state.labelField} vs ${state.valueField}`]))}'
    selected-palette="${state.palette}">
  </scatter-chart>
</div>${dsfrDeferredScript('scatter-chart')}`;
    codeEl.textContent = code;
    return;
  }

  // Handle Map type (local data)
  if (state.chartType === 'map') {
    // For choropleth maps, use sequential or divergent palette for gradient
    const mapPalette = state.palette.includes('sequential') || state.palette.includes('divergent')
      ? state.palette
      : 'sequentialAscending';

    // Transform data to DSFR format: {"code": value, ...}
    const mapData: Record<string, number> = {};
    let totalValue = 0;
    let count = 0;

    state.data.forEach(d => {
      const rawCode = (d[state.codeField] ?? (d as any).code ?? '') as string | number;
      let code = String(rawCode).trim();
      if (/^\d+$/.test(code) && code.length < 3) {
        code = code.padStart(2, '0');
      }
      const value = (d.value as number) || 0;
      if (isValidDeptCode(code) && !isNaN(value)) {
        mapData[code] = Math.round(value * 100) / 100;
        totalValue += value;
        count++;
      }
    });

    const avgValue = count > 0 ? Math.round((totalValue / count) * 100) / 100 : 0;
    const today = new Date().toISOString().split('T')[0];

    const mapCode = `<!-- Carte g\u00e9n\u00e9r\u00e9e avec gouv-widgets Builder -->
<!-- Source : ${state.savedSource?.name || 'Donn\u00e9es locales'} -->
<!-- Palette: ${mapPalette} -->

<!-- D\u00e9pendances CSS (DSFR) -->
<link rel="stylesheet" href="${CDN_URLS.dsfrCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrUtilityCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrChartCss}">
<script type="module" src="${CDN_URLS.dsfrChartJs}"><\/script>

<div class="fr-container fr-my-4w">
  <h2>${escapeHtml(state.title)}</h2>
  ${state.subtitle ? `<p class="fr-text--sm fr-text--light">${escapeHtml(state.subtitle)}</p>` : ''}
  <map-chart
    data='${JSON.stringify(mapData)}'
    name="${escapeHtml(state.title || 'Donn\u00e9es')}"
    date="${today}"
    value="${avgValue}"
    selected-palette="${mapPalette}"
  ></map-chart>
</div>${dsfrDeferredScript('map-chart')}`;
    codeEl.textContent = mapCode;
    return;
  }

  // Build DSFR Chart element for static embed
  const labels = state.data.map(d => (d[state.labelField] as string) || 'N/A');
  const values = state.data.map(d => Math.round(((d.value as number) || 0) * 100) / 100);

  const hasSecondSeries = state.valueField2 && ['bar', 'horizontalBar', 'line', 'radar'].includes(state.chartType);
  const values2 = hasSecondSeries
    ? state.data.map(d => Math.round(((d.value2 as number) || 0) * 100) / 100)
    : null;

  const dsfrTag = DSFR_TAG_MAP[state.chartType] || 'bar-chart';
  const x = JSON.stringify([labels]);
  const y = values2 ? JSON.stringify([values, values2]) : JSON.stringify([values]);
  const seriesNames = values2
    ? JSON.stringify([state.valueField, state.valueField2])
    : JSON.stringify([state.valueField]);

  // Build extra attributes
  const extraAttrs: string[] = [];
  if (state.chartType === 'horizontalBar') extraAttrs.push('horizontal');
  if (state.chartType === 'pie') extraAttrs.push('fill');
  const extraStr = extraAttrs.map(a => `\n    ${a}`).join('');

  const code = `<!-- Graphique genere avec gouv-widgets Builder -->
<!-- Source : ${state.savedSource?.name || 'Donnees locales'} -->

<!-- Dependances (DSFR + DSFR Chart) -->
<link rel="stylesheet" href="${CDN_URLS.dsfrCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrUtilityCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrChartCss}">
<script type="module" src="${CDN_URLS.dsfrChartJs}"><\/script>

<div class="fr-container fr-my-4w">
  <h2>${escapeHtml(state.title)}</h2>
  ${state.subtitle ? `<p class="fr-text--sm fr-text--light">${escapeHtml(state.subtitle)}</p>` : ''}

  <${dsfrTag}
    x='${escapeSingleQuotes(x)}'
    y='${escapeSingleQuotes(y)}'
    name='${escapeSingleQuotes(seriesNames)}'
    selected-palette="${state.palette}"${extraStr}>
  </${dsfrTag}>
</div>${dsfrDeferredScript(dsfrTag)}`;

  codeEl.textContent = code;
}


/**
 * Generate a <gouv-query api-type="opendatasoft"> element for ODS sources.
 * Uses server-side aggregation (ODSQL) with automatic pagination,
 * bypassing gouv-source entirely.
 */
export function generateOdsQueryCode(
  odsInfo: { baseUrl: string; datasetId: string },
  labelFieldPath: string,
  valueFieldPath: string
): { queryElement: string; chartSource: string; labelField: string; valueField: string; valueField2: string } {
  const attrs: string[] = [];
  attrs.push('api-type="opendatasoft"');
  attrs.push(`base-url="${odsInfo.baseUrl}"`);
  attrs.push(`dataset-id="${odsInfo.datasetId}"`);

  // Group by
  const groupByField = state.advancedMode && state.queryGroupBy ? state.queryGroupBy : labelFieldPath;
  if (groupByField) {
    attrs.push(`group-by="${groupByField}"`);
  }

  // Build ODSQL select clause with aggregation
  let resultValueField: string;
  let resultValueField2 = '';
  let selectParts: string[] = [];
  if (groupByField) selectParts.push(groupByField);

  const hasSecondSeries = state.valueField2 && ['bar', 'horizontalBar', 'line', 'radar'].includes(state.chartType);

  if (state.advancedMode && state.queryAggregate) {
    // Advanced mode: parse custom aggregation expressions
    const aggParts = state.queryAggregate.split(',').map(a => a.trim());
    for (const agg of aggParts) {
      const segs = agg.split(':');
      if (segs.length >= 2) {
        const field = segs[0];
        const func = segs[1];
        const alias = segs[2] || `${field}__${func}`;
        selectParts.push(`${func}(${field}) as ${alias}`);
      }
    }
    const firstAgg = aggParts[0].split(':');
    resultValueField = firstAgg[2] || `${firstAgg[0]}__${firstAgg[1]}`;
  } else {
    // Standard mode: use form aggregation
    if (state.aggregation === 'count') {
      selectParts.push('count(*) as count');
      resultValueField = 'count';
    } else {
      const alias = `${valueFieldPath}__${state.aggregation}`;
      selectParts.push(`${state.aggregation}(${valueFieldPath}) as ${alias}`);
      resultValueField = alias;

      // Add second series aggregation
      if (hasSecondSeries) {
        const alias2 = `${state.valueField2}__${state.aggregation}`;
        selectParts.push(`${state.aggregation}(${state.valueField2}) as ${alias2}`);
        resultValueField2 = alias2;
      }
    }
  }
  attrs.push(`select="${escapeHtml(selectParts.join(', '))}"`);

  // Where / filter
  if (state.advancedMode && state.queryFilter) {
    const odsql = filterToOdsql(state.queryFilter);
    if (odsql) attrs.push(`where="${escapeHtml(odsql)}"`);
  }

  // Order by (ODSQL syntax: "field DESC")
  if (state.sortOrder && state.sortOrder !== 'none') {
    attrs.push(`order-by="${resultValueField}:${state.sortOrder}"`);
  }

  // No explicit limit: gouv-query api-type="opendatasoft" with limit=0
  // (default) fetches ALL available records with automatic pagination
  // (pages of 100, using total_count from API response to detect completion)

  const queryElement = `
  <!-- Requete ODS avec agregation serveur et pagination automatique -->
  <gouv-query
    id="query-data"
    ${attrs.join('\n    ')}>
  </gouv-query>`;

  return {
    queryElement,
    chartSource: 'query-data',
    labelField: groupByField,
    valueField: resultValueField,
    valueField2: resultValueField2,
  };
}

/**
 * Generate a <gouv-query api-type="tabular"> element for Tabular API sources.
 * Uses automatic pagination (up to 50K records) with client-side aggregation,
 * bypassing gouv-source entirely.
 */
export function generateTabularQueryCode(
  tabularInfo: { baseUrl: string; resourceId: string },
  labelFieldPath: string,
  valueFieldPath: string
): { queryElement: string; chartSource: string; labelField: string; valueField: string; valueField2: string } {
  const attrs: string[] = [];
  attrs.push('api-type="tabular"');
  attrs.push(`base-url="${tabularInfo.baseUrl}"`);
  attrs.push(`resource="${tabularInfo.resourceId}"`);

  // Group by
  const groupByField = state.advancedMode && state.queryGroupBy ? state.queryGroupBy : labelFieldPath;
  if (groupByField) {
    attrs.push(`group-by="${groupByField}"`);
  }

  // Aggregation (colon syntax for client-side processing)
  let resultValueField: string;
  let resultValueField2 = '';
  let aggregateExpr: string;

  const hasSecondSeries = state.valueField2 && ['bar', 'horizontalBar', 'line', 'radar'].includes(state.chartType);

  if (state.advancedMode && state.queryAggregate) {
    aggregateExpr = state.queryAggregate;
    const firstAgg = aggregateExpr.split(',')[0].trim();
    const parts = firstAgg.split(':');
    resultValueField = parts.length >= 2 ? `${parts[0]}__${parts[1]}` : groupByField;
  } else {
    aggregateExpr = `${valueFieldPath}:${state.aggregation}`;
    resultValueField = `${valueFieldPath}__${state.aggregation}`;

    if (hasSecondSeries) {
      const vf2Info = state.fields.find(f => f.name === state.valueField2);
      const valueField2Path = vf2Info?.fullPath || state.valueField2;
      aggregateExpr += `, ${valueField2Path}:${state.aggregation}`;
      resultValueField2 = `${valueField2Path}__${state.aggregation}`;
    }
  }
  attrs.push(`aggregate="${escapeHtml(aggregateExpr)}"`);

  // Filter (colon syntax)
  if (state.advancedMode && state.queryFilter) {
    attrs.push(`filter="${escapeHtml(state.queryFilter)}"`);
  }

  // Order by
  if (state.sortOrder && state.sortOrder !== 'none') {
    attrs.push(`order-by="${resultValueField}:${state.sortOrder}"`);
  }

  const queryElement = `
  <!-- Requete Tabular avec pagination automatique et agregation client-side -->
  <gouv-query
    id="query-data"
    ${attrs.join('\n    ')}>
  </gouv-query>`;

  return {
    queryElement,
    chartSource: 'query-data',
    labelField: groupByField,
    valueField: resultValueField,
    valueField2: resultValueField2,
  };
}

/**
 * Generate gouv-query HTML for dynamic mode.
 * Always generates a <gouv-query> to handle aggregation, sorting and filtering.
 * Returns { queryElement, chartSource, labelField, valueField }.
 */
export function generateGouvQueryCode(
  sourceId: string,
  labelFieldPath: string,
  valueFieldPath: string
): { queryElement: string; chartSource: string; labelField: string; valueField: string; valueField2: string } {
  const attrs: string[] = [];
  attrs.push(`source="${sourceId}"`);

  // Group by: advanced custom field or default labelField
  const groupByField = state.advancedMode && state.queryGroupBy ? state.queryGroupBy : labelFieldPath;
  if (groupByField) {
    attrs.push(`group-by="${groupByField}"`);
  }

  // Filters (advanced mode only)
  if (state.advancedMode && state.queryFilter) {
    attrs.push(`filter="${escapeHtml(state.queryFilter)}"`);
  }

  // Aggregations: advanced custom or default from form
  let aggregateExpr: string;
  let sortField: string;
  let resultValueField: string;
  let resultValueField2 = '';

  const hasSecondSeries = state.valueField2 && ['bar', 'horizontalBar', 'line', 'radar'].includes(state.chartType);
  // Resolve valueField2 path for dynamic mode
  const vf2Info = state.fields.find(f => f.name === state.valueField2);
  const valueField2Path = vf2Info?.fullPath || state.valueField2;

  if (state.advancedMode && state.queryAggregate) {
    aggregateExpr = state.queryAggregate;
    const firstAgg = aggregateExpr.split(',')[0].trim();
    const parts = firstAgg.split(':');
    sortField = parts.length >= 2 ? `${parts[0]}__${parts[1]}` : groupByField;
    resultValueField = sortField;
  } else {
    aggregateExpr = `${valueFieldPath}:${state.aggregation}`;
    // Add second series aggregation
    if (hasSecondSeries) {
      aggregateExpr += `, ${valueField2Path}:${state.aggregation}`;
      resultValueField2 = `${valueField2Path}__${state.aggregation}`;
    }
    sortField = `${valueFieldPath}__${state.aggregation}`;
    resultValueField = sortField;
  }
  attrs.push(`aggregate="${escapeHtml(aggregateExpr)}"`);

  // Sort
  if (state.sortOrder && state.sortOrder !== 'none') {
    attrs.push(`order-by="${sortField}:${state.sortOrder}"`);
  }

  const comment = state.advancedMode
    ? '<!-- Requete avancee (filtrage et agregation) -->'
    : '<!-- Agregation et tri des donnees -->';

  const queryElement = `
  ${comment}
  <gouv-query
    id="query-data"
    ${attrs.join('\n    ')}>
  </gouv-query>`;

  return {
    queryElement,
    chartSource: 'query-data',
    labelField: groupByField,
    valueField: resultValueField,
    valueField2: resultValueField2,
  };
}

/**
 * Generate code using gouv-source + gouv-chart for Grist sources.
 */
export function generateDynamicCode(): void {
  const source = state.savedSource;
  if (!source || source.type !== 'grist') return;

  const codeEl = document.getElementById('generated-code');
  if (!codeEl) return;

  // Build full proxy URL via ProviderConfig knownHosts
  const gristProvider = getProvider('grist');
  let proxyUrl = source.apiUrl || '';
  let gristHost = 'Grist';

  for (const host of gristProvider.knownHosts) {
    if (source.apiUrl?.includes(host.hostname)) {
      proxyUrl = `${PROXY_BASE_URL}${host.proxyEndpoint}/api/docs/${source.documentId}/tables/${source.tableId}/records`;
      gristHost = host.hostname;
      break;
    }
  }

  // Get field info for labels
  const labelFieldInfo = state.fields.find(f => f.name === state.labelField);
  const valueFieldInfo = state.fields.find(f => f.name === state.valueField);

  // After normalize flatten, data has flat field names (not nested fields.X)
  const isFlattened = state.normalizeConfig.enabled && !!state.normalizeConfig.flatten;
  const labelFieldPath = isFlattened ? state.labelField : (labelFieldInfo?.fullPath || `fields.${state.labelField}`);
  const valueFieldPath = isFlattened ? state.valueField : (valueFieldInfo?.fullPath || `fields.${state.valueField}`);

  const refreshAttr = state.refreshInterval > 0 ? `\n    refresh="${state.refreshInterval}"` : '';

  // Grist data has {fields: {X: ...}} structure — prefix facet field paths when not flattened
  const gristFacetsMode: FacetsMode | undefined = isFlattened ? undefined : { fieldPrefix: 'fields.' };

  // Handle KPI type (no DSFR Chart equivalent, fallback to embedded)
  if (state.chartType === 'kpi') {
    generateCodeForLocalData();
    return;
  }

  // Handle Datalist type (Grist dynamic)
  if (state.chartType === 'datalist') {
    const colonnes = buildColonnesAttr();
    const triAttr = state.sortOrder !== 'none' && state.labelField
      ? `\n    tri="${state.labelField}:${state.sortOrder}"` : '';
    const { elements: middlewareHtml, finalSourceId: datalistSource } = generateMiddlewareElements('table-data', gristFacetsMode);
    const code = `<!-- Tableau dynamique genere avec gouv-widgets Builder -->
<!-- Source : ${escapeHtml(source.name)} (chargement dynamique depuis ${gristHost}) -->

<!-- Dependances CSS (DSFR) -->
<link rel="stylesheet" href="${CDN_URLS.dsfrCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrUtilityCss}">

<!-- Dependances JS -->
<script src="${PROXY_BASE_URL}/dist/gouv-widgets.umd.js"><\/script>

<div class="fr-container fr-my-4w">
  ${state.title ? `<h2>${escapeHtml(state.title)}</h2>` : ''}
  ${state.subtitle ? `<p class="fr-text--sm fr-text--light">${escapeHtml(state.subtitle)}</p>` : ''}

  <gouv-source
    id="table-data"
    url="${proxyUrl}"
    transform="records"${refreshAttr}>
  </gouv-source>
${middlewareHtml}
  <gouv-datalist
    source="${datalistSource}"
    colonnes="${colonnes}"${buildDatalistAttrs()}${triAttr}
    pagination="10">
  </gouv-datalist>
</div>`;
    codeEl.textContent = code;
    return;
  }

  // Middleware (normalize, facets) between source and query
  const { elements: middlewareHtml, finalSourceId: querySourceId } = generateMiddlewareElements('chart-data', gristFacetsMode);

  // For maps, group by codeField (not labelField)
  const isMap = state.chartType === 'map' || state.chartType === ('mapReg' as any);
  const groupByPath = isMap && state.codeField
    ? (isFlattened ? state.codeField : (`fields.${state.codeField}`))
    : labelFieldPath;

  // Generate gouv-query for aggregation, sorting, filtering
  const { queryElement, chartSource, labelField: queryLabelField, valueField: queryValueField, valueField2: queryValueField2 } =
    generateGouvQueryCode(querySourceId, groupByPath, valueFieldPath);

  // Map palette
  const palette = isMap
    ? (state.palette.includes('sequential') || state.palette.includes('divergent') ? state.palette : 'sequentialAscending')
    : state.palette;

  // Map-specific attributes
  const codeFieldAttr = isMap && state.codeField ? `\n    code-field="${state.codeField}"` : '';

  // Second series attribute
  const valueField2Attr = queryValueField2 ? `\n    value-field-2="${queryValueField2}"` : '';

  const code = `<!-- Graphique dynamique genere avec gouv-widgets Builder -->
<!-- Source : ${escapeHtml(source.name)} (chargement dynamique depuis ${gristHost}) -->
<!-- Les donnees sont chargees via le proxy ${PROXY_BASE_URL} -->
${state.advancedMode ? '<!-- Mode avance active : filtrage et agregation via gouv-query -->' : ''}

<!-- Dependances CSS (DSFR) -->
<link rel="stylesheet" href="${CDN_URLS.dsfrCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrUtilityCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrChartCss}">

<!-- Dependances JS -->
<script type="module" src="${CDN_URLS.dsfrChartJs}"><\/script>
<script src="${PROXY_BASE_URL}/dist/gouv-widgets.umd.js"><\/script>

<div class="fr-container fr-my-4w">
  ${state.title ? `<h2>${escapeHtml(state.title)}</h2>` : ''}
  ${state.subtitle ? `<p class="fr-text--sm fr-text--light">${escapeHtml(state.subtitle)}</p>` : ''}

  <!-- Source de donnees (via proxy chartsbuilder.matge.com) -->
  <gouv-source
    id="chart-data"
    url="${proxyUrl}"
    transform="records"${refreshAttr}>
  </gouv-source>
${middlewareHtml}${queryElement}
  <!-- Graphique DSFR (se met a jour automatiquement) -->
  <gouv-dsfr-chart
    source="${chartSource}"
    type="${state.chartType === 'horizontalBar' ? 'bar' : state.chartType === 'doughnut' ? 'pie' : state.chartType}"${dsfrChartAttrs()}${codeFieldAttr}
    label-field="${queryLabelField}"
    value-field="${queryValueField}"${valueField2Attr}
    name="${escapeHtml(state.title || state.valueField)}"
    selected-palette="${palette}">
  </gouv-dsfr-chart>
</div>`;

  codeEl.textContent = code;
}

/**
 * Generate code using gouv-source + gouv-dsfr-chart for API sources.
 */
export function generateDynamicCodeForApi(): void {
  const source = state.savedSource;
  if (!source || source.type !== 'api') return;

  const codeEl = document.getElementById('generated-code');
  if (!codeEl) return;

  // Detect provider and extract resource IDs using centralized infrastructure
  const provider = source.apiUrl ? detectProvider(source.apiUrl) : getProvider('generic');
  const resourceIds = source.apiUrl ? extractResourceIds(source.apiUrl, provider) : null;
  const apiBaseUrl = source.apiUrl ? new URL(source.apiUrl).origin : '';

  // Get field paths — after normalize flatten, data has flat field names
  const labelFieldInfo = state.fields.find(f => f.name === state.labelField);
  const valueFieldInfo = state.fields.find(f => f.name === state.valueField);

  const isFlattened = state.normalizeConfig.enabled && !!state.normalizeConfig.flatten;
  const labelFieldPath = isFlattened ? state.labelField : (labelFieldInfo?.fullPath || state.labelField);
  const valueFieldPath = isFlattened ? state.valueField : (valueFieldInfo?.fullPath || state.valueField);

  const refreshAttr = state.refreshInterval > 0 ? `\n    refresh="${state.refreshInterval}"` : '';

  // Handle data path transform
  const transformAttr = source.dataPath ? `\n    transform="${source.dataPath}"` : '';

  // Handle KPI type (no DSFR Chart equivalent, fallback to embedded)
  if (state.chartType === 'kpi') {
    generateCodeForLocalData();
    return;
  }

  // Handle Datalist type (API dynamic)
  if (state.chartType === 'datalist') {
    const colonnes = buildColonnesAttr();
    const triAttr = state.sortOrder !== 'none' && state.labelField
      ? `\n    tri="${state.labelField}:${state.sortOrder}"` : '';

    if (provider.id === 'opendatasoft' && resourceIds?.datasetId) {
      const whereAttr = state.advancedMode && state.queryFilter
        ? `\n    where="${escapeHtml(filterToOdsql(state.queryFilter))}"` : '';
      // Facettes serveur ODS (fetch depuis l'API /facets)
      const facets = generateFacetsElement('table-data', { serverFacets: true });
      const datalistSource = facets.element ? facets.finalSourceId : 'table-data';
      const code = `<!-- Tableau dynamique genere avec gouv-widgets Builder -->
<!-- Source : ${escapeHtml(source.name)} (pagination serveur : une page a la fois) -->

<!-- Dependances CSS (DSFR) -->
<link rel="stylesheet" href="${CDN_URLS.dsfrCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrUtilityCss}">

<!-- Dependances JS -->
<script src="${PROXY_BASE_URL}/dist/gouv-widgets.umd.js"><\/script>

<div class="fr-container fr-my-4w">
  ${state.title ? `<h2>${escapeHtml(state.title)}</h2>` : ''}
  ${state.subtitle ? `<p class="fr-text--sm fr-text--light">${escapeHtml(state.subtitle)}</p>` : ''}

  <gouv-query
    id="table-data"
    api-type="opendatasoft"
    base-url="${apiBaseUrl}"
    dataset-id="${resourceIds!.datasetId}"${whereAttr}
    server-side
    page-size="20">
  </gouv-query>
${facets.element}
  <gouv-datalist
    source="${datalistSource}"
    colonnes="${colonnes}"${buildDatalistAttrs()}${triAttr}
    server-tri
    pagination="20">
  </gouv-datalist>
</div>`;
      codeEl.textContent = code;
      return;
    }

    if (provider.id === 'tabular' && resourceIds?.resourceId) {
      const filterAttr = state.advancedMode && state.queryFilter
        ? `\n    filter="${escapeHtml(state.queryFilter)}"` : '';
      // Facettes pre-calculees (Tabular ne supporte pas les facettes serveur)
      const staticVals = computeStaticFacetValues();
      const facets = generateFacetsElement('table-data', staticVals ? { staticValues: staticVals } : undefined);
      const datalistSource = facets.element ? facets.finalSourceId : 'table-data';
      const code = `<!-- Tableau dynamique genere avec gouv-widgets Builder -->
<!-- Source : ${escapeHtml(source.name)} (pagination serveur : une page a la fois) -->

<!-- Dependances CSS (DSFR) -->
<link rel="stylesheet" href="${CDN_URLS.dsfrCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrUtilityCss}">

<!-- Dependances JS -->
<script src="${PROXY_BASE_URL}/dist/gouv-widgets.umd.js"><\/script>

<div class="fr-container fr-my-4w">
  ${state.title ? `<h2>${escapeHtml(state.title)}</h2>` : ''}
  ${state.subtitle ? `<p class="fr-text--sm fr-text--light">${escapeHtml(state.subtitle)}</p>` : ''}

  <gouv-query
    id="table-data"
    api-type="tabular"
    base-url="${apiBaseUrl}"
    resource="${resourceIds!.resourceId}"${filterAttr}
    server-side
    page-size="20">
  </gouv-query>
${facets.element}
  <gouv-datalist
    source="${datalistSource}"
    colonnes="${colonnes}"${buildDatalistAttrs()}${triAttr}
    server-tri
    pagination="20">
  </gouv-datalist>
</div>`;
      codeEl.textContent = code;
      return;
    }

    // Generic API: use gouv-source (no automatic pagination)
    const { elements: middlewareHtml, finalSourceId: datalistSource } = generateMiddlewareElements('table-data');
    const code = `<!-- Tableau dynamique genere avec gouv-widgets Builder -->
<!-- Source : ${escapeHtml(source.name)} (chargement dynamique) -->

<!-- Dependances CSS (DSFR) -->
<link rel="stylesheet" href="${CDN_URLS.dsfrCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrUtilityCss}">

<!-- Dependances JS -->
<script src="${PROXY_BASE_URL}/dist/gouv-widgets.umd.js"><\/script>

<div class="fr-container fr-my-4w">
  ${state.title ? `<h2>${escapeHtml(state.title)}</h2>` : ''}
  ${state.subtitle ? `<p class="fr-text--sm fr-text--light">${escapeHtml(state.subtitle)}</p>` : ''}

  <gouv-source
    id="table-data"
    url="${source.apiUrl}"${transformAttr}${refreshAttr}>
  </gouv-source>
${middlewareHtml}
  <gouv-datalist
    source="${datalistSource}"
    colonnes="${colonnes}"${buildDatalistAttrs()}${triAttr}
    pagination="10">
  </gouv-datalist>
</div>`;
    codeEl.textContent = code;
    return;
  }

  // For maps, group by codeField (not labelField)
  const isMap = state.chartType === 'map' || state.chartType === ('mapReg' as any);
  const groupByPath = isMap && state.codeField ? state.codeField : labelFieldPath;

  let queryElement: string;
  let chartSource: string;
  let queryLabelField: string;
  let queryValueField: string;
  let queryValueField2 = '';
  let sourceElement: string;
  let middlewareHtml = '';
  let facetsHtml = '';

  if (provider.id === 'opendatasoft' && resourceIds?.datasetId) {
    // ODS source: use gouv-query with api-type="opendatasoft" for
    // server-side aggregation and automatic pagination (limit > 100)
    const odsInfo = { baseUrl: apiBaseUrl, datasetId: resourceIds.datasetId };
    const result = generateOdsQueryCode(odsInfo, groupByPath, valueFieldPath);
    queryElement = result.queryElement;
    chartSource = result.chartSource;
    queryLabelField = result.labelField;
    queryValueField = result.valueField;
    queryValueField2 = result.valueField2 || '';
    sourceElement = '';
    // Facets after ODS query (filters aggregated results)
    const facets = generateFacetsElement(chartSource);
    if (facets.element) { facetsHtml = facets.element; chartSource = facets.finalSourceId; }
  } else if (provider.id === 'tabular' && resourceIds?.resourceId) {
    // Tabular source: use gouv-query with api-type="tabular" for
    // automatic pagination (up to 50K records) and client-side aggregation
    const tabularInfo = { baseUrl: apiBaseUrl, resourceId: resourceIds.resourceId };
    const result = generateTabularQueryCode(tabularInfo, groupByPath, valueFieldPath);
    queryElement = result.queryElement;
    chartSource = result.chartSource;
    queryLabelField = result.labelField;
    queryValueField = result.valueField;
    queryValueField2 = result.valueField2 || '';
    sourceElement = '';
    // Facets after Tabular query (filters aggregated results)
    const facets = generateFacetsElement(chartSource);
    if (facets.element) { facetsHtml = facets.element; chartSource = facets.finalSourceId; }
  } else {
    // Non-ODS/Tabular source: use gouv-source + gouv-query (generic, client-side)
    const mw = generateMiddlewareElements('chart-data');
    middlewareHtml = mw.elements;
    const result = generateGouvQueryCode(mw.finalSourceId, groupByPath, valueFieldPath);
    queryElement = result.queryElement;
    chartSource = result.chartSource;
    queryLabelField = result.labelField;
    queryValueField = result.valueField;
    queryValueField2 = result.valueField2 || '';
    sourceElement = `
  <!-- Source de donnees API -->
  <gouv-source
    id="chart-data"
    url="${source.apiUrl}"${transformAttr}${refreshAttr}>
  </gouv-source>`;
  }

  // Map palette
  const palette = isMap
    ? (state.palette.includes('sequential') || state.palette.includes('divergent') ? state.palette : 'sequentialAscending')
    : state.palette;

  // Map-specific attributes
  const codeFieldAttr = isMap && state.codeField ? `\n    code-field="${state.codeField}"` : '';

  // Second series attribute
  const valueField2Attr = queryValueField2 ? `\n    value-field-2="${queryValueField2}"` : '';

  const code = `<!-- Graphique dynamique genere avec gouv-widgets Builder -->
<!-- Source : ${escapeHtml(source.name)} (chargement dynamique) -->
${state.advancedMode ? '<!-- Mode avance active : filtrage et agregation via gouv-query -->' : ''}

<!-- Dependances CSS (DSFR) -->
<link rel="stylesheet" href="${CDN_URLS.dsfrCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrUtilityCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrChartCss}">

<!-- Dependances JS -->
<script type="module" src="${CDN_URLS.dsfrChartJs}"><\/script>
<script src="${PROXY_BASE_URL}/dist/gouv-widgets.umd.js"><\/script>

<div class="fr-container fr-my-4w">
  ${state.title ? `<h2>${escapeHtml(state.title)}</h2>` : ''}
  ${state.subtitle ? `<p class="fr-text--sm fr-text--light">${escapeHtml(state.subtitle)}</p>` : ''}
${sourceElement}${middlewareHtml}${queryElement}${facetsHtml}
  <!-- Graphique DSFR (se met a jour automatiquement) -->
  <gouv-dsfr-chart
    source="${chartSource}"
    type="${state.chartType === 'horizontalBar' ? 'bar' : state.chartType === 'doughnut' ? 'pie' : state.chartType}"${dsfrChartAttrs()}${codeFieldAttr}
    label-field="${queryLabelField}"
    value-field="${queryValueField}"${valueField2Attr}
    name="${escapeHtml(state.title || state.valueField)}"
    selected-palette="${palette}">
  </gouv-dsfr-chart>
</div>`;

  codeEl.textContent = code;
}

/**
 * Generate HTML+JS code for API-fetched data.
 */
export function generateCode(apiUrl: string): void {
  const codeEl = document.getElementById('generated-code');
  if (!codeEl) return;

  // Handle KPI type
  if (state.chartType === 'kpi') {
    const variantSelect = document.getElementById('kpi-variant') as HTMLSelectElement | null;
    const unitInput = document.getElementById('kpi-unit') as HTMLInputElement | null;
    const variant = variantSelect?.value || '';
    const unit = unitInput?.value || '';

    const code = `<!-- KPI g\u00e9n\u00e9r\u00e9 avec gouv-widgets Builder -->

<!-- D\u00e9pendances CSS (DSFR) -->
<link rel="stylesheet" href="${CDN_URLS.dsfrCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrUtilityCss}">

<style>
.kpi-card {
  background: var(--background-default-grey);
  border-left: 4px solid var(--border-default-grey);
  padding: 1.5rem 2rem;
  text-align: center;
  border-radius: 4px;
}
.kpi-card--info { border-left-color: #0063CB; }
.kpi-card--success { border-left-color: #18753C; }
.kpi-card--warning { border-left-color: #D64D00; }
.kpi-card--error { border-left-color: #C9191E; }
.kpi-value { display: block; font-size: 2.5rem; font-weight: 700; color: var(--text-title-grey); }
.kpi-label { display: block; font-size: 0.875rem; color: var(--text-mention-grey); margin-top: 0.5rem; }
</style>

<div class="fr-container fr-my-4w">
  <div class="kpi-card${variant ? ' kpi-card--' + variant : ''}" id="kpi-container">
    <span class="kpi-value" id="kpi-value">\u2014</span>
    <span class="kpi-label">${escapeHtml(state.title)}</span>
  </div>
</div>

<script>
// URL de l'API avec agr\u00e9gation
const API_URL = '${apiUrl}';

function formatKPIValue(value, unit) {
  const num = Math.round(value * 100) / 100;
  if (unit === '\u20ac' || unit === 'EUR') {
    return new Intl.NumberFormat('fr-FR', { style: 'currency', currency: 'EUR' }).format(num);
  } else if (unit === '%') {
    return new Intl.NumberFormat('fr-FR', { maximumFractionDigits: 1 }).format(num) + ' %';
  } else {
    const formatted = new Intl.NumberFormat('fr-FR', { maximumFractionDigits: 2 }).format(num);
    return unit ? formatted + ' ' + unit : formatted;
  }
}

async function loadKPI() {
  const response = await fetch(API_URL);
  const json = await response.json();
  const data = json.results || [];
  const value = data[0]?.value || 0;
  document.getElementById('kpi-value').textContent = formatKPIValue(value, '${unit}');
}

loadKPI();
<\/script>`;
    codeEl.textContent = code;
    return;
  }

  // Handle Gauge type
  if (state.chartType === 'gauge') {
    const code = `<!-- Jauge g\u00e9n\u00e9r\u00e9e avec gouv-widgets Builder -->

<!-- D\u00e9pendances CSS (DSFR) -->
<link rel="stylesheet" href="${CDN_URLS.dsfrCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrUtilityCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrChartCss}">
<script type="module" src="${CDN_URLS.dsfrChartJs}"><\/script>

<div class="fr-container fr-my-4w">
  <h2>${escapeHtml(state.title)}</h2>
  ${state.subtitle ? `<p class="fr-text--sm fr-text--light">${escapeHtml(state.subtitle)}</p>` : ''}
  <div id="gauge-container"></div>
</div>

<script type="module">
const API_URL = '${apiUrl}';

async function loadGauge() {
  const response = await fetch(API_URL);
  const json = await response.json();
  const value = Math.round(json.results?.[0]?.value || 0);

  document.getElementById('gauge-container').innerHTML = \`
    <gauge-chart percent="\${value}" init="0" target="100"></gauge-chart>
  \`;
}

loadGauge();
<\/script>`;
    codeEl.textContent = code;
    return;
  }

  // Handle Datalist type (API fetch)
  if (state.chartType === 'datalist') {
    const colonnes = buildColonnesAttr();
    const triAttr = state.sortOrder !== 'none' && state.labelField
      ? `\n    tri="${state.labelField}:${state.sortOrder}"` : '';
    const code = `<!-- Tableau genere avec gouv-widgets Builder -->

<!-- Dependances CSS (DSFR) -->
<link rel="stylesheet" href="${CDN_URLS.dsfrCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrUtilityCss}">

<!-- Dependances JS -->
<script src="${PROXY_BASE_URL}/dist/gouv-widgets.umd.js"><\/script>

<div class="fr-container fr-my-4w">
  ${state.title ? `<h2>${escapeHtml(state.title)}</h2>` : ''}
  ${state.subtitle ? `<p class="fr-text--sm fr-text--light">${escapeHtml(state.subtitle)}</p>` : ''}

  <gouv-datalist
    id="my-table"
    colonnes="${colonnes}"${buildDatalistAttrs()}${triAttr}
    pagination="10">
  </gouv-datalist>
</div>

<script>
const API_URL = '${apiUrl}';

${ODS_FETCH_HELPER}

async function loadTable() {
  const data = await fetchAllODS(API_URL);
  document.getElementById('my-table').onSourceData(data);
}

loadTable();
<\/script>`;
    codeEl.textContent = code;
    return;
  }

  // Handle Scatter type
  if (state.chartType === 'scatter') {
    const code = `<!-- Nuage de points genere avec gouv-widgets Builder -->

<!-- Dependances (DSFR + DSFR Chart) -->
<link rel="stylesheet" href="${CDN_URLS.dsfrCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrUtilityCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrChartCss}">
<script type="module" src="${CDN_URLS.dsfrChartJs}"><\/script>

<div class="fr-container fr-my-4w">
  <h2>${escapeHtml(state.title)}</h2>
  ${state.subtitle ? `<p class="fr-text--sm fr-text--light">${escapeHtml(state.subtitle)}</p>` : ''}
  <div id="scatter-container"></div>
</div>

<script type="module">
const API_URL = '${apiUrl}';

${ODS_FETCH_HELPER}

async function loadChart() {
  const data = await fetchAllODS(API_URL);

  const xValues = data.map(d => d['${state.labelField}'] || 0);
  const yValues = data.map(d => d.value || 0);

  var el = document.createElement('scatter-chart');
  el.setAttribute('x', JSON.stringify([xValues]));
  el.setAttribute('y', JSON.stringify([yValues]));
  el.setAttribute('name', ${JSON.stringify(JSON.stringify([`${state.labelField} vs ${state.valueField}`]))});
  el.setAttribute('selected-palette', '${state.palette}');
  document.getElementById('scatter-container').appendChild(el);
}

loadChart();
<\/script>`;
    codeEl.textContent = code;
    return;
  }

  // Handle Map type
  if (state.chartType === 'map') {
    // For choropleth maps, use sequential or divergent palette for gradient
    const mapPalette = state.palette.includes('sequential') || state.palette.includes('divergent')
      ? state.palette
      : 'sequentialAscending';

    const code = `<!-- Carte g\u00e9n\u00e9r\u00e9e avec gouv-widgets Builder -->
<!-- Palette: ${mapPalette} -->

<!-- D\u00e9pendances CSS (DSFR) -->
<link rel="stylesheet" href="${CDN_URLS.dsfrCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrUtilityCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrChartCss}">
<script type="module" src="${CDN_URLS.dsfrChartJs}"><\/script>

<div class="fr-container fr-my-4w">
  <h2>${escapeHtml(state.title)}</h2>
  ${state.subtitle ? `<p class="fr-text--sm fr-text--light">${escapeHtml(state.subtitle)}</p>` : ''}
  <div id="map-container"></div>
</div>

<script type="module">
const API_URL = '${apiUrl}';

${ODS_FETCH_HELPER}

// Valide un code de d\u00e9partement fran\u00e7ais
function isValidDeptCode(code) {
  if (!code || typeof code !== 'string') return false;
  if (['N/A', 'null', 'undefined', '00', ''].includes(code)) return false;
  if (code === '2A' || code === '2B') return true;
  if (/^97[1-6]$/.test(code)) return true;
  if (/^(0[1-9]|[1-8]\\d|9[0-5])$/.test(code)) return true;
  return false;
}

async function loadMap() {
  const records = await fetchAllODS(API_URL);

  // Transformer les donn\u00e9es en format carte: {"code": valeur, ...}
  const mapData = {};
  records.forEach(d => {
    let code = String(d['${state.codeField}'] || '').trim();
    if (/^\\d+$/.test(code) && code.length < 3) {
      code = code.padStart(2, '0');
    }
    const value = d.value || 0;
    if (isValidDeptCode(code)) {
      mapData[code] = Math.round(value * 100) / 100;
    }
  });

  var el = document.createElement('map-chart');
  el.setAttribute('data', JSON.stringify(mapData));
  el.setAttribute('name', '${escapeHtml(state.title)}');
  el.setAttribute('selected-palette', '${mapPalette}');
  // Compute national average
  var vals = Object.values(mapData);
  var avg = vals.length ? Math.round(vals.reduce(function(a,b){return a+b},0) / vals.length * 100) / 100 : 0;
  el.setAttribute('value', String(avg));
  el.setAttribute('date', new Date().toISOString().split('T')[0]);
  document.getElementById('map-container').appendChild(el);
}

loadMap();
<\/script>`;
    codeEl.textContent = code;
    return;
  }

  // Build DSFR Chart type and extra attributes
  const hasSecondSeries = state.valueField2 && ['bar', 'horizontalBar', 'line', 'radar'].includes(state.chartType);
  const dsfrTag = DSFR_TAG_MAP[state.chartType] || 'bar-chart';

  const extraAttrs: string[] = [];
  if (state.chartType === 'horizontalBar') extraAttrs.push('horizontal');
  if (state.chartType === 'pie') extraAttrs.push('fill');

  const seriesNames = hasSecondSeries
    ? JSON.stringify([state.valueField, state.valueField2])
    : JSON.stringify([state.valueField]);

  const code = `<!-- Graphique genere avec gouv-widgets Builder -->

<!-- Dependances (DSFR + DSFR Chart) -->
<link rel="stylesheet" href="${CDN_URLS.dsfrCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrUtilityCss}">
<link rel="stylesheet" href="${CDN_URLS.dsfrChartCss}">
<script type="module" src="${CDN_URLS.dsfrChartJs}"><\/script>

<div class="fr-container fr-my-4w">
  <h2>${escapeHtml(state.title)}</h2>
  ${state.subtitle ? `<p class="fr-text--sm fr-text--light">${escapeHtml(state.subtitle)}</p>` : ''}
  <div id="chart-container"></div>
</div>

<script type="module">
// URL de l'API avec agregation
const API_URL = '${apiUrl}';

${ODS_FETCH_HELPER}

async function loadChart() {
  const data = await fetchAllODS(API_URL);

  const labels = data.map(d => d['${state.labelField}'] || 'N/A');
  const values = data.map(d => Math.round((d.value || 0) * 100) / 100);${hasSecondSeries ? `
  const values2 = data.map(d => Math.round((d.value2 || 0) * 100) / 100);` : ''}

  const y = ${hasSecondSeries ? 'JSON.stringify([values, values2])' : 'JSON.stringify([values])'};

  var el = document.createElement('${dsfrTag}');
  el.setAttribute('x', JSON.stringify([labels]));
  el.setAttribute('y', y);
  el.setAttribute('name', '${escapeSingleQuotes(seriesNames)}');
  el.setAttribute('selected-palette', '${state.palette}');${state.chartType === 'horizontalBar' ? `
  el.setAttribute('horizontal', '');` : ''}${state.chartType === 'pie' ? `
  el.setAttribute('fill', '');` : ''}
  document.getElementById('chart-container').appendChild(el);
}

loadChart();
<\/script>`;

  codeEl.textContent = code;
}
