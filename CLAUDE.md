# CLAUDE.md - Configuration du projet gouv-widgets

## Contexte du projet

Bibliotheque de Web Components de dataviz pour sites gouvernementaux francais.
Composants Lit conformes DSFR (Design System de l'Etat).
Architecture monorepo avec npm workspaces.

## Architecture

```
/
├── index.html               # Hub (page d'accueil)
├── apps/                    # Applications TypeScript
│   ├── builder/             # Generateur visuel de graphiques
│   ├── builder-ia/          # Generateur IA avec Albert
│   ├── dashboard/           # Editeur visuel de tableaux de bord (grille par ligne, preview, save/delete)
│   ├── sources/             # Gestionnaire de sources de donnees
│   ├── playground/          # Environnement de code interactif
│   ├── favorites/           # Gestion des favoris
│   └── monitoring/          # Monitoring et logs
├── packages/
│   └── shared/              # Utilitaires partages (@gouv-widgets/shared)
├── src/                     # Composants web gouv-widgets (Lit)
│   ├── adapters/            # Adapters API (ODS, Tabular, Grist, Generic)
│   └── components/          # Composants Lit (gouv-source, gouv-query, ...)
├── dist/                    # Build output (ESM + UMD)
├── specs/                   # Specifications des composants
├── guide/                   # Guide utilisateur et exemples
├── tests/                   # Tests Vitest + Playwright E2E
├── e2e/                     # Tests E2E Playwright
├── src-tauri/               # App desktop Tauri
├── scripts/                 # Scripts de build
└── app-dist/                # Build output pour Tauri (genere)
```

## Commandes disponibles

```bash
npm run dev           # Serveur de dev Vite (port 5173)
npm run build         # Build bibliotheque TypeScript + Vite
npm run build:shared  # Build du package shared
npm run build:apps    # Build de toutes les apps
npm run build:all     # Build complet (shared + lib + apps)
npm run build:app     # Assembler app-dist/ pour Tauri
npm run test          # Tests Vitest en watch mode
npm run test:run      # Tests une seule fois
npm run test:coverage # Tests avec couverture
npm run preview       # Preview du build
npm run tauri:dev     # Dev Tauri (app desktop)
npm run tauri:build   # Build Tauri production (build:all + build:app + tauri build)
```

### Dev d'une app individuelle

```bash
npm run dev --workspace=@gouv-widgets/app-builder
npm run dev --workspace=@gouv-widgets/app-builder-ia
npm run dev --workspace=@gouv-widgets/app-dashboard
npm run dev --workspace=@gouv-widgets/app-sources
npm run dev --workspace=@gouv-widgets/app-playground
npm run dev --workspace=@gouv-widgets/app-favorites
npm run dev --workspace=@gouv-widgets/app-monitoring
```

## Architecture des composants data

### Pipeline recommande

```
gouv-source  ──[fetch via adapter]──[paginate]──[cache]──► donnees brutes
     │                                                         │
     │ adapters (ODS, Tabular, Grist, Generic)                 ▼
     │                                               gouv-query [transform seulement]
     │◄── commandes (groupBy, aggregate, orderBy) ─── delegation server-side
     │                                               filter, group-by, aggregate, sort
     │                                                         │
     │                                                         ▼
     │                                               gouv-normalize (optionnel, renommage)
     │                                                         │
     │                                    ┌────────────────────┤
     │                                    ▼                    ▼
     │                              gouv-facets          gouv-search
     │                                    │                    │
     │◄── commandes (page, where, orderBy)┘                    │
     │◄── commandes (where) ───────────────────────────────────┘
     ▼
  gouv-dsfr-chart / gouv-datalist / gouv-kpi / gouv-display
         │
         └──► gouv-raw-data (companion optionnel, telechargement CSV + ARIA)
```

**Regles** :
- **gouv-source** est le seul composant qui fait du fetch HTTP. Il supporte `api-type` pour ODS, Tabular, Grist et Generic.
- **gouv-query** est un pur transformateur de donnees (filter, group-by, aggregate, sort). Il ne fait jamais de requete HTTP.
- **gouv-query** negocie automatiquement la delegation server-side : si `source` pointe directement sur un `gouv-source` avec un adapter qui supporte `serverGroupBy`/`serverOrderBy`, il envoie des commandes pour que l'API fasse le group-by/aggregate/sort cote serveur. Si la source est un intermediaire (normalize, facets), le traitement reste client-side.
- **gouv-normalize** se place de preference **apres** gouv-query quand on veut beneficier de la delegation server-side (renommage cosmetique apres agregation). Il peut aussi se placer avant gouv-query si le nettoyage est necessaire pour les filtres (ex: conversion numerique), mais cela force le traitement client-side.
- Les commandes (page, where, orderBy) remontent vers gouv-source via `gouv-source-command`.
- **gouv-facets et gouv-search** restent toujours **avant** gouv-query dans les pipelines filtre+agregation : l'ordre "filtrer puis agreger" est semantiquement different de "agreger puis filtrer". Le traitement est client-side dans ces cas.
- gouv-facets et gouv-search delegent la construction des WHERE clauses aux adapters.

### Pattern HTML

```html
<!-- Source (fetch) → Query (transform, delegation server-side) → Normalize (renommage) → Chart -->
<gouv-source id="src" api-type="opendatasoft"
  dataset-id="mon-dataset" base-url="https://data.economie.gouv.fr">
</gouv-source>
<gouv-query id="data" source="src"
  group-by="nom_region" aggregate="population:sum:total" order-by="total:desc">
</gouv-query>
<gouv-normalize id="clean" source="data"
  rename="nom_region:Region">
</gouv-normalize>
<gouv-dsfr-chart id="mon-graph" source="clean" type="bar"
  label-field="Region" value-field="total">
</gouv-dsfr-chart>
<!-- Optionnel : telechargement CSV accessible -->
<gouv-raw-data for="mon-graph" source="clean"></gouv-raw-data>
```

Pour les cas sans transformation (datalist, display), gouv-query peut etre omis :

```html
<gouv-source id="src" api-type="tabular"
  resource="..." server-side page-size="20">
</gouv-source>
<gouv-datalist source="src" colonnes="..." pagination="20">
</gouv-datalist>
```

Pour les pipelines avec facettes (filtrer puis agreger — client-side) :

```html
<gouv-source id="src" api-type="opendatasoft"
  base-url="https://data.economie.gouv.fr" dataset-id="mon-dataset">
</gouv-source>
<gouv-facets id="filtered" source="src" server-facets
  fields="nom_region" display="nom_region:multiselect">
</gouv-facets>
<gouv-query id="stats" source="filtered"
  group-by="nom_departement" aggregate="population:sum:total" order-by="total:desc">
</gouv-query>
<gouv-dsfr-chart source="stats" type="bar"
  label-field="nom_departement" value-field="total">
</gouv-dsfr-chart>
```

### Adapters et ProviderConfig

- **Adapters** (`src/adapters/`) : construisent les URLs, parsent les reponses, gerent la pagination. Chaque API a son adapter (ODS, Tabular, Grist, Generic).
- **ProviderConfig** (`packages/shared/src/providers/`) : configuration declarative par provider (pagination, response parsing, query syntax, code generation).
- **Registre** (`src/adapters/adapter-registry.ts`) : `getAdapter(apiType)` retourne l'adapter pour un type donne.
- Ajouter un nouveau provider (CKAN...) = 1 ProviderConfig + 1 Adapter, zero modification dans les composants.

### Capacites des adapters

| Capacite | OpenDataSoft | Tabular | Grist | INSEE (Melodi) | Generic |
|----------|:---:|:---:|:---:|:---:|:---:|
| serverFetch | oui | oui | oui | oui | non |
| serverFacets | oui | non | oui | non | non |
| serverSearch | oui | non | non | non | non |
| serverGroupBy | oui | oui | oui | non | non |
| serverOrderBy | oui | oui | oui | non | non |
| whereFormat | odsql | colon | colon | colon | odsql |

**Formats WHERE** :
- **ODSQL** (OpenDataSoft) : syntaxe SQL-like — `population > 5000 AND status = 'active'`
- **Colon** (Tabular, Grist) : syntaxe structuree — `field:operator:value, field2:operator:value2`

### Attributs gouv-source

gouv-source fonctionne en deux modes :

**Mode URL (fetch direct)** : `url`, `method`, `headers`, `params`, `refresh`, `transform`, `paginate`, `page-size`, `cache-ttl`, `data` (inline JSON)

**Mode adapter** (api-type != generic ou base-url fourni) : `api-type`, `base-url`, `dataset-id`, `resource`, `where`, `select`, `group-by`, `aggregate`, `order-by`, `server-side`, `page-size`, `limit`

### Grist : mode Records vs SQL

L'adapter Grist choisit automatiquement entre deux modes :
- **Mode Records** (GET /records) : pour fetch simple, filter equality/IN (`?filter={"col":["v"]}`), sort (`?sort=-col`), pagination (`?limit=N&offset=M`)
- **Mode SQL** (POST /sql) : pour group-by, aggregation, LIKE search, facettes DISTINCT via SQL parametre

Le mode SQL est un fallback automatique — il est active seulement quand les capacites de l'endpoint Records sont insuffisantes (group-by, aggregate, operateurs avances comme contains/gt/lt). Si le endpoint SQL n'est pas disponible sur l'instance Grist, l'adapter revient au mode Records + client-side. La disponibilite SQL est cachee par hostname (`Map<string, boolean>`).

L'adapter expose aussi `fetchColumns()` et `fetchTables()` pour l'introspection du schema Grist.

## Conventions de code

- TypeScript strict mode
- Composants Lit (LitElement, html, css)
- Nommage : `gouv-*` pour les composants publics, `app-*` pour les layouts
- Tests : fichiers `*.test.ts` dans `/tests/`
- Pas d'emoji dans le code sauf demande explicite
- Imports partages via `@gouv-widgets/shared`

## Package shared (@gouv-widgets/shared)

Utilitaires partages entre toutes les apps :
- `escapeHtml()` - Echappement HTML
- `formatKPIValue()`, `formatDateShort()` - Formatage
- `toNumber()`, `looksLikeNumber()` - Parsing numerique
- `isValidDeptCode()` - Validation codes departementaux
- `DSFR_COLORS`, `PALETTE_COLORS` - Palettes DSFR
- `getProxyConfig()`, `getProxiedUrl()` - Configuration proxy
- `loadFromStorage()`, `saveToStorage()`, `STORAGE_KEYS` - localStorage
- `openModal()`, `closeModal()` - Modales DSFR
- `toastWarning()`, `toastSuccess()` - Notifications toast DSFR
- `appHref()`, `navigateTo()` - Navigation inter-apps
- `ProviderConfig`, `getProviderConfig()` - Configuration declarative des providers API
- `detectProvider()` - Detection automatique du type de provider depuis une URL

## Skills builder-IA (alignement composants)

Le builder-IA (`apps/builder-ia/`) utilise un systeme de skills : des blocs de connaissances injectes dans le prompt de l'IA selon le contexte. Les skills sont definis dans `apps/builder-ia/src/skills.ts`.

**Regle importante** : quand on ajoute/modifie un attribut, un type de graphique, un operateur de filtre ou une fonction d'agregation dans un composant `gouv-*`, il faut mettre a jour le skill correspondant dans `skills.ts`.

Les tests d'alignement dans `tests/apps/builder-ia/skills.test.ts` verifient automatiquement que :
- Chaque attribut HTML d'un composant est documente dans son skill (via introspection Lit `elementProperties`)
- Tous les types de graphiques, operateurs de filtre et fonctions d'agregation sont couverts
- Chaque composant data a un skill correspondant

Si un attribut est ajoute a un composant sans maj du skill, le test echouera.

**Note** : gouv-source a deux modes (voir "Attributs gouv-source" ci-dessus). gouv-query est un pur transformateur et ne fait aucun fetch HTTP.

## Release Tauri

La release est declenchee par un tag git :
```bash
git tag v0.2.0
git push origin v0.2.0
```
Le workflow `.github/workflows/release.yml` build automatiquement sur macOS (ARM + x86), Linux (deb + AppImage) et Windows (NSIS + MSI).

## APIs externes utilisees

- Grist : docs.getgrist.com, grist.numerique.gouv.fr
- Albert IA : albert.api.etalab.gouv.fr
- OpenDataSoft : *.opendatasoft.com
- Tabular API : tabular-api.data.gouv.fr
- INSEE Melodi : api.insee.fr/melodi (catalogue-donnees.insee.fr)

## Proxy

- Dev : Vite proxy (configure dans vite.config.ts de chaque app)
- Production : chartsbuilder.matge.com (nginx)
- Tauri : proxy distant via detection `window.__TAURI__`
- Configurable via `VITE_PROXY_URL`

## Beacon de tracking

Chaque composant `gouv-*` envoie un beacon fire-and-forget a l'initialisation (`connectedCallback`) via `sendWidgetBeacon()` dans `src/utils/beacon.ts`. Le beacon transmet le nom du composant, le type de graphique et l'origine de la page (`window.location.origin` via le parametre `r=`) au proxy nginx qui les enregistre dans `beacon.log`. Un script periodique (`scripts/parse-beacon-logs.sh`) transforme ces logs en `monitoring-data.json` consomme par l'app monitoring.

- Le parametre `r=` envoie `window.location.origin` pour identifier le site deployeur (plus fiable que le header HTTP Referer qui depend du Referrer-Policy du site)
- Les parsers (sh et js) preferent `$arg_r` et tombent en fallback sur `$http_referer` pour compatibilite avec les anciens logs
- Deduplication par `Set` en memoire (1 beacon par composant+type par page)
- Skip en dev (localhost/127.0.0.1)
- Utilise un pixel de tracking (`new Image().src`) au lieu de `fetch()` : les requetes image sont regies par `img-src` (CSP) qui est quasi-toujours permissif, contrairement a `connect-src` qui bloque souvent les appels `fetch` cross-origin

## Build : esbuild keepNames

Le `vite.config.ts` contient `esbuild: { keepNames: true }`. Cette option est **obligatoire** :
sans elle, esbuild supprime les methodes privees non-decorees des prototypes de classes Lit
lors de la minification (ex: `_processMapData`, `_createChartElement`), ce qui casse le
fonctionnement des composants en production. Overhead negligeable (~2 Ko).

## DSFR Chart : attributs differes (deferred)

Les composants DSFR Chart (`map-chart`, `map-chart-reg`) sont des Web Components Vue qui
ecrasent certains attributs (`value`, `date`) avec leurs valeurs par defaut lors du montage Vue.
`gouv-dsfr-chart` utilise un mecanisme de `setTimeout(500ms)` pour re-appliquer ces attributs
apres le montage Vue (voir `_createChartElement` dans `src/components/gouv-dsfr-chart.ts`).

Si un nouveau composant DSFR Chart presente le meme comportement, ajouter les attributs
concernes dans l'objet `deferred` retourne par `_getTypeSpecificAttributes()`.

## Tauri : zoom par defaut

L'app desktop Tauri applique un zoom de 80% au demarrage via `window.set_zoom(0.8)` dans
`src-tauri/src/lib.rs`. Cela permet d'afficher plus de contenu dans la fenetre sans
modifier le CSS des composants. Le zoom est applique cote Rust dans le hook `setup`.

## Communication inter-apps (sessionStorage)

Les builders et les favoris envoient du code au playground via `sessionStorage` :
1. L'app source stocke le code dans `sessionStorage.setItem('playground-code', code)`
2. Elle navigue vers le playground avec un parametre `?from=builder` (ou `builder-ia`, `favorites`)
3. Le playground lit le parametre `from`, charge le code depuis sessionStorage, et le supprime

Le parametre `from` doit etre l'un de : `builder`, `builder-ia`, `favorites`.

## Tests exhaustifs du Builder (Playwright E2E)

Tests dans `tests/builder-e2e/` : verifient la generation de code pour toutes les
combinaisons source x type de graphique x mode (embedded/dynamic/dynamic+facettes).

**Pre-requis** : le serveur de dev principal doit tourner (port 5173) car les sources
API (ODS, Tabular) ont besoin du proxy Vite. Playwright doit etre installe.

```bash
# 1. Lancer le serveur de dev (dans un terminal separe)
npm run dev

# 2. Lancer les tests exhaustifs du builder
npx playwright test --config tests/builder-e2e/playwright.config.ts
```

- **110 tests** : 4 sources (locale, ODS, Tabular, Grist) x 11 types de graphique x modes
- Resultats ecrits dans `tests/builder-e2e/RESULTS.md`
- Screenshots par combinaison dans `tests/builder-e2e/screenshots/`
- Sources de test : locale (donnees embarquees), ODS et Tabular (APIs distantes via proxy),
  Grist (donnees embarquees, pas de proxy en dev)

## Tests de validation des parametres Builder (Playwright E2E)

Tests dans `tests/builder-e2e/` : valident que tous les parametres du builder fonctionnent correctement et generent le code attendu avec des donnees de test connues.

**Pre-requis** : le serveur de dev doit tourner (port 5173) pour acceder au builder.

```bash
# 1. Lancer le serveur de dev (dans un terminal separe)
npm run dev

# 2. Lancer les tests de validation des parametres
cd tests/builder-e2e
npx playwright test quick-audit.spec.ts

# 3. Tests de base (elements UI)
npx playwright test simple-test.spec.ts

# 4. Inspection de la structure (diagnostic)
npx playwright test inspect-builder.spec.ts --headed
```

### Tests de validation critiques

**11/12 tests passent** (91.7% de reussite) :

- **Fonctions d'agregation** (5/5) : SUM, AVG, MIN, MAX, COUNT
- **Types de graphiques** (4/4) : bar, horizontalBar, pie, kpi
- **Palettes** : Application correcte des couleurs
- **Tri** : Ordre ascendant et descendant
- **Mode avance** : Filtres et conditions

### Donnees de test et valeurs attendues

Les tests utilisent un dataset de test avec valeurs connues pour verification :

```typescript
const TEST_DATA = [
  { region: 'Ile-de-France', population: 12000, budget: 500, code: '75' },
  { region: 'Provence', population: 5000, budget: 200, code: '13' },
  { region: 'Bretagne', population: 3000, budget: 150, code: '35' },
  { region: 'Normandie', population: 3300, budget: 180, code: '14' }
];
```

**Valeurs attendues** (field: population) :
- SUM = 23300
- AVG = 5825
- MIN = 3000
- MAX = 12000
- COUNT = 4 (nombre de regions)

### Exposition du state pour les tests

Pour permettre aux tests de verifier les calculs, le state du builder est expose globalement dans `apps/builder/src/main.ts` :

```typescript
// Expose state for E2E tests
(window as any).__BUILDER_STATE__ = state;
```

Cette exposition permet aux tests de :
- Injecter des donnees de test directement dans le state
- Verifier que les agregations calculent les valeurs correctes
- Comparer les resultats avec les valeurs attendues
- Valider la coherence entre donnees source et resultats affiches

### Documentation complete

- `tests/builder-e2e/README.md` : Guide d'utilisation des tests
- `tests/builder-e2e/RESULTAT_TESTS.md` : Resultats detailles des tests
- `tests/builder-e2e/QUICK_START.md` : Demarrage rapide et troubleshooting
- `tests/builder-e2e/FIX_TESTS.md` : Guide de resolution des problemes
- `tests/builder-e2e/SYNTHESE.md` : Synthese et vue d'ensemble
- `tests/builder-e2e/TESTING_MATRIX.md` : Matrice complete des parametres a tester

### Utilitaires de test

- `data-consistency-checker.ts` : Calcul des valeurs attendues et verification de coherence
- `inspect-builder.spec.ts` : Outil de diagnostic de la structure du builder
- `simple-test.spec.ts` : Tests de base (elements UI, options disponibles)
- `quick-audit.spec.ts` : Tests critiques de validation des parametres

## Notes importantes

- Les fichiers `.js` dans `/src/` sont des artefacts de build, ne pas les modifier
- Toujours lancer `npm run build` apres modification des composants
- Docker : `docker compose up -d --build` (utilise un volume `beacon-logs` pour persister les donnees de monitoring entre redemarrages)
